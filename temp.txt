import pandas as pd
import math
import numpy as np

# --- Assume adaptive_mixture_score is defined as before ---
def adaptive_mixture_score(
    llm_confidence: float, # Expects NORMALIZED input (0-1)
    ocr_quality: float,    # Expects NORMALIZED input (0-1)
    lambda_threshold: float,
    k_steepness: float,
    entity_factor: float = 1.0
) -> float:
    """Calculates adaptive score using NORMALIZED inputs."""
    if k_steepness <= 0:
        raise ValueError("k_steepness must be positive.")

    exponent_term = k_steepness * (lambda_threshold - llm_confidence)
    try:
        alpha = 1.0 / (1.0 + np.exp(exponent_term))
    except OverflowError:
        if exponent_term > 700: alpha = 0.0
        elif exponent_term < -700: alpha = 1.0
        else: raise

    effective_ocr_quality = entity_factor * ocr_quality
    score = alpha * llm_confidence + (1.0 - alpha) * effective_ocr_quality
    # Returns a NORMALIZED score
    return score
# -------------------------------------------------------------

def normalize_score(score):
    """Normalizes a score from 1-100 range to 0-1 range."""
    # Handle potential non-numeric or NaN values gracefully
    if pd.isna(score) or not isinstance(score, (int, float)):
        return np.nan # Or handle error as appropriate
    return (max(1.0, min(100.0, score)) - 1.0) / 99.0 # Clip score to 1-100 first

def denormalize_score(norm_score):
    """Converts a normalized 0-1 score back to 1-100 range."""
    if pd.isna(norm_score):
        return np.nan
    return norm_score * 99.0 + 1.0

def apply_adaptive_score_to_dataframe_normalized(
    df: pd.DataFrame,
    ocr_col_name: str,         # Column with 1-100 score
    llm_col_name: str,         # Column with 1-100 score
    output_col_name: str,
    lambda_threshold: float,   # Threshold for NORMALIZED LLM score (0-1)
    k_steepness: float,        # Steepness (positive)
    entity_factor: float = 1.0,
    output_denormalized: bool = True, # Option to get 1-100 output
    inplace: bool = False
) -> pd.DataFrame:
    """
    Applies adaptive_mixture_score row-wise to a DataFrame, handling
    1-100 input normalization.

    Args:
        df: Input DataFrame.
        ocr_col_name: Name of the column with 1-100 OCR scores.
        llm_col_name: Name of the column with 1-100 LLM scores.
        output_col_name: Name for the new score column.
        lambda_threshold: Threshold for NORMALIZED LLM score (e.g., 0.1).
        k_steepness: Steepness (e.g., 30.0).
        entity_factor: Optional factor for OCR quality.
        output_denormalized: If True, the output column will be scaled back to 1-100.
                             If False, it will be the normalized 0-1 score.
        inplace: Modify DataFrame directly or return a copy.

    Returns:
        DataFrame with the new adaptive score column.
    """
    if not inplace:
        df = df.copy()

    # --- Input Validation (simplified for example) ---
    if ocr_col_name not in df.columns or llm_col_name not in df.columns:
        raise KeyError("Input columns not found.")
    if k_steepness <= 0:
        raise ValueError("k_steepness must be positive.")
    # Add more robust type/NaN checks if needed
    # ---------------------------------------------

    print(f"Applying adaptive score: LLM='{llm_col_name}', OCR='{ocr_col_name}' -> '{output_col_name}'")
    print(f"Using NORM lambda={lambda_threshold}, k={k_steepness}, entity_factor={entity_factor}")

    # Apply row-wise, including normalization inside the lambda
    calculated_scores = df.apply(
        lambda row: adaptive_mixture_score(
            llm_confidence=normalize_score(row[llm_col_name]),
            ocr_quality=normalize_score(row[ocr_col_name]),
            lambda_threshold=lambda_threshold,
            k_steepness=k_steepness,
            entity_factor=entity_factor
        ),
        axis=1
    )

    if output_denormalized:
        df[output_col_name] = calculated_scores.apply(denormalize_score)
        print("Output score denormalized to 1-100 range.")
    else:
        df[output_col_name] = calculated_scores
        print("Output score remains in normalized 0-1 range.")


    print("Calculation complete.")
    return df

# --- Example Usage ---

# Sample DataFrame with 1-100 scores
data = {
    'aws_ocr_mean_conf': [95, 80, 99, 30, 90, 5], # OCR 1-100
    'llm_log_prob_score': [98, 50, 90, 95, 10, 90]  # LLM 1-100
}
my_df = pd.DataFrame(data)

# Suggested Parameters for Low OCR Weight
LAMBDA_PARAM = 0.1 # Low threshold on normalized LLM score
K_PARAM = 30.0     # High steepness

OUTPUT_COLUMN = 'LowOCRWeight_Score'

try:
    updated_df = apply_adaptive_score_to_dataframe_normalized(
        df=my_df,
        ocr_col_name='aws_ocr_mean_conf',
        llm_col_name='llm_log_prob_score',
        output_col_name=OUTPUT_COLUMN,
        lambda_threshold=LAMBDA_PARAM,
        k_steepness=K_PARAM,
        output_denormalized=True # Get output back in 1-100 scale
    )

    print("\nDataFrame with Low OCR Weight Score (1-100):")
    print(updated_df)

except (KeyError, TypeError, ValueError) as e:
    print(f"\nError processing DataFrame: {e}")
